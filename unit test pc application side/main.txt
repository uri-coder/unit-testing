const char* ip = "192.168.8.2";
struct sockaddr_in addr;

tast_recurses_t* test_raw_results_list;
tasting_thread_pack_t* test_thread_input_list;
pthread_t* thread_handel_list;
card_name_and_id_t card_id_in;
app_data_init_commend_t commend;

int
main() {

    int port = APP_INIT_PORT;
    int sockfd;
    int check;
    socklen_t addr_size = sizeof(struct sockaddr_in);
    uint8_t index;
    tast_recurses_t* temp_ptr;
    uint16_t list_len;
    linux_app_tast_setting_t tast_handel_in;
    uint8_t lib_check;
    srand(time(NULL));
    /*
     creating a socket to get infomation from stm card.
     is id and name the list of test to run and other setting of the test

  */
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {

        perror("socket failed");
        exit(1);
    }
    memset(&addr, '\0', sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(ip);

    /* request uid  and name of stm32 chip under test */
    commend.type = ID_REQWEST;
    check = sendto(sockfd, (void*)&commend, sizeof(commend), 0, (struct sockaddr*)&addr, sizeof(addr));
    if (check == -1) {

        perror("Failed  to send massage");
        return 1;
    }
    check = recvfrom(sockfd, (void*)&card_id_in, sizeof(card_id_in), 0, (struct sockaddr*)&addr, &addr_size);
    if (check == -1) {

        perror("Failed  to  receive massage");
        return 1;
    }

    printf("card part number: %s\n", card_id_in.board_part_number);
    printf("card UID %" PRIu32 "  ::  %" PRIu32 "  ::  %" PRIu32 " \n", card_id_in.id[0], card_id_in.id[1],
           card_id_in.id[2]);

    memcpy(commend.id, card_id_in.id, ID_SIZE * sizeof(uint32_t));

    /* talk  */

    /* request the size of list of tests to run and allocate  memory to store the list */

    commend.type = LIST_SIZE_REQUEST;
    check = sendto(sockfd, (void*)&commend, sizeof(commend), 0, (struct sockaddr*)&addr, sizeof(addr));
    if (check == -1) {

        perror("Failed  to send massage");
        return 1;
    }

    check = recvfrom(sockfd, (void*)&list_len, sizeof(list_len), 0, (struct sockaddr*)&addr, &addr_size);
    if (check == -1) {

        perror("Failed  to  receive massage");
        return 1;
    }
    /* allocates memory to store the test list and test results */
    test_raw_results_list = (tast_recurses_t*)malloc(sizeof(tast_recurses_t) * list_len);
    if (test_raw_results_list == NULL) {
        return 8;
    }

    /* read the list of tests from and store them in allocated memory */

    commend.type = LIST_MEMBER_REQUEST;
    uint16_t thread_num = 0;

    for (uint16_t i = 0; i < list_len; i++) {

        commend.list_index = i;

        check = sendto(sockfd, (void*)&commend, sizeof(commend), 0, (struct sockaddr*)&addr, sizeof(addr));
        if (check == -1) {

            perror("Failed  to send massage");
            return 1;
        }
        check = recvfrom(sockfd, (void*)&test_raw_results_list[i].test_request_pack, sizeof(linux_app_tast_setting_t),
                         0, (struct sockaddr*)&addr, &addr_size);
        if (check == -1) {

            perror("Failed  to receive massage");
            return 1;
        }

        if (test_raw_results_list[i].test_request_pack.tast_name[0] == '#') {
            thread_num++;
        }
    }

    close(sockfd);

    /*     */
    test_thread_input_list = (tasting_thread_pack_t*)malloc(sizeof(tasting_thread_pack_t) * thread_num);
    if (test_thread_input_list == NULL) {
        return 5;
    }

    thread_handel_list = (pthread_t*)malloc(sizeof(pthread_t) * thread_num);
    if (thread_handel_list == NULL) {
        return 6;
    }

    /*      */

    temp_ptr = test_raw_results_list;
    for (uint16_t thread_handle_num = 0; thread_handle_num < thread_num; thread_handle_num++) {
        index = 0;

        while (temp_ptr[index].test_request_pack.tast_name[0] != '#') {
            index++;
        }

        index++;

        /* init the setting for thread */
        test_thread_input_list[thread_handle_num].number_of_tast = index;
        test_thread_input_list[thread_handle_num].first_tast_adrr = temp_ptr;

        /* creating socket for thread */
        test_thread_input_list[thread_handle_num].thread_socket.task_port_socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
        if (test_thread_input_list[thread_handle_num].thread_socket.task_port_socket_fd == -1) {
            perror("socket feild");
            return 3 + thread_handle_num;
        }
        memset(&test_thread_input_list[thread_handle_num].thread_socket.addr, '\0', sizeof(addr));
        test_thread_input_list[thread_handle_num].thread_socket.addr.sin_family = AF_INET;
        test_thread_input_list[thread_handle_num].thread_socket.addr.sin_port = htons(SERVER_OFFEST_PORT
                                                                                      + thread_handle_num);
        test_thread_input_list[thread_handle_num].thread_socket.addr.sin_addr.s_addr = inet_addr(ip);
        test_thread_input_list[thread_handle_num].thread_socket.addr_size = sizeof(struct sockaddr_in);
        temp_ptr = &temp_ptr[index];
    }

    for (uint16_t thread_create_index = 0; thread_create_index < thread_num; thread_create_index++) {

        check = pthread_create(&thread_handel_list[thread_create_index], NULL, testing_thread,
                               &test_thread_input_list[thread_create_index]);
        if (check != 0) {

            perror("Failed  to create thread");
            return 1;
        }
    }

    for (uint16_t thread_join_index = 0; thread_join_index < thread_num; thread_join_index++) {

        check = pthread_join(thread_handel_list[thread_join_index], NULL);
        if (check != 0) {

            perror("Failed  to join thread");

            return 1;
        }
    }

    lib_check = generate_result_file(test_raw_results_list, list_len, &card_id_in);

    if (lib_check != GF_OK) {

        perror(" Failed to generate result file ");
        return 1;
    }

    for (uint16_t thread_socket = 0; thread_socket < thread_num; thread_socket++) {

        close(test_thread_input_list[thread_socket].thread_socket.task_port_socket_fd);
    }

    free(test_thread_input_list);
    test_thread_input_list = NULL;

    free(thread_handel_list);
    thread_handel_list = NULL;

    free(test_raw_results_list);
    test_raw_results_list = NULL;

    printf("program and\n");
}
